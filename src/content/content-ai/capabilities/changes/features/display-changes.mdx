---
title: 自定义变更的显示方式
meta:
  title: 显示变更 | Tiptap AI 变更
  description: 通过自定义样式和弹出框定制编辑器中 AI 变更的显示方式。
  category: 内容 AI
---

AI Changes 扩展设计时考虑到了灵活性。作为一个无头库，它让你可以完全控制变更在编辑器中的显示方式。

## 默认样式

默认情况下，AI Changes 扩展会应用 CSS 类以突出显示被修改的内容：

- `tiptap-ai-changes--old` 表示被删除的文本
- `tiptap-ai-changes--new` 表示被插入的文本

扩展本身不包含任何内置样式，因此你需要自行定义 CSS。以下是变更高亮的基础样式完整示例：

```css
:root {
  --color-green-100: oklch(0.962 0.044 156.743);
  --color-green-700: oklch(0.527 0.154 150.069);
  --color-red-100: oklch(0.936 0.032 17.717);
  --color-red-700: oklch(0.505 0.213 27.518);
}

.tiptap-ai-changes--old,
.tiptap-ai-changes--old > * {
  color: var(--color-red-700);
  background-color: var(--color-red-100);
}

.tiptap-ai-changes--new,
.tiptap-ai-changes--new > * {
  color: var(--color-green-700);
  background-color: var(--color-green-100);
}
```

这会给被删除的文本应用红色背景，给被插入的文本应用绿色背景。

想要更高级的样式，可以使用 `getCustomDecorations` [配置选项](/content-ai/capabilities/changes/configure#custom-styles)。

## 选中的变更

当选区光标位于某个变更上时，该变更被视为“已选中”。

你可以从扩展的存储对象中获取已选中的变更：

```ts
const storage = editor.extensionStorage.aiChanges
const selectedChange = storage.getSelectedChange()
```

要以编程方式选中某个变更，可以使用 `selectAiChange` 命令。

```ts
editor.commands.selectAiChange(changeId)
```

这会将光标移动到变更的起始位置，从而使其被视为“选中”。

选中变更的文本可以在 `getCustomDecorations` 函数中引用，以对其应用自定义样式。

## 自定义变更的外观

`getCustomDecorations` 选项允许你控制变更的外观，为用户提供视觉提示。

它接收以下参数：

- `change`: 包含变更信息的变更对象。
- `changes`: 所有被跟踪变更的列表。
- `isSelected`: 布尔值，表示该变更是否被选中。变更光标位于其上时则为选中。
- `getDefaultDecorations`: 返回该变更默认装饰的函数。如果未提供 `getCustomDecorations`，将使用默认装饰。
- `editor`: Tiptap 编辑器实例。
- `previousDoc`: AI 变更前的文档。变更是通过对比当前文档与该文档产生的。
- `currentDoc`: AI 变更后的文档。

```ts
AiChanges.configure({
  getCustomDecorations({ change, isSelected, getDefaultDecorations }) {
    // 你可以将 AI Changes 扩展默认的装饰与自定义装饰结合起来
    const decorations = getDefaultDecorations()

    // 在变更插入文本后添加自定义元素
    decorations.push(
      Decoration.widget(change.newRange.to, () => {
        const element = document.createElement('span')

        element.textContent = '✅'
        return element
      }),
    )
    return decorations
  },
})
```

自定义样式和元素是通过 [Prosemirror 装饰 API](https://prosemirror.net/docs/ref/#view.Decorations) 实现的。

想了解如何在选中变更时显示弹出框，请参阅本指南 [显示选中变更时的弹出框](/content-ai/capabilities/changes/features/display-changes#show-a-popover-when-a-change-is-selected)。

## 选中变更时显示弹出框

在多数用户审阅工作流程中，你需要在选中的变更上方显示弹出框或工具提示，提供接受或拒绝等操作。

要在选中变更时显示弹出框，请使用 `getCustomDecorations` 选项。它允许你向变更添加自定义元素，包括弹出框。

下面是一个使用 React 的简化示例：

```tsx
// 首先，定义一个状态钩子来保存弹出框挂载的 HTML 元素
const [popoverElement, setPopoverElement] = useState<HTMLElement | null>(null)

AiChanges.configure({
  getCustomDecorations({ change, isSelected, getDefaultDecorations }) {
    const decorations = getDefaultDecorations()

    // 然后，创建一个 Prosemirror 装饰，包含该 HTML 元素
    // 在变更插入文本后，当变更被选中时添加自定义元素
    if (isSelected) {
      decorations.push(
        Decoration.widget(change.newRange.to, () => {
          const element = document.createElement('span')

          setPopoverElement(element)
          return element
        }),
      )
    }
    return decorations
  },
})

const selectedChange = editor.extensionStorage.aiChanges.getSelectedChange()
if (popoverElement && selectedChange) {
  // 然后，向自定义元素添加 HTML 内容。在此示例中，我们使用 React Portals 来渲染弹出框。
  ReactDOM.createPortal(<Popover change={selectedChange} />, popoverElement)
}
```

我们推荐使用 [Floating UI](https://floating-ui.com/) 库来显示弹出框。你可以在[演示示例](/content-ai/capabilities/changes/overview)中查看具体用法。

## 在编辑器外部的侧边栏显示变更

你可以从扩展的[存储对象](/content-ai/capabilities/changes/api-reference#extension-storage)访问变更数据：

```ts
const storage = editor.extensionStorage.aiChanges
const changes = storage.getChanges()
```

然后利用这些数据渲染自定义 UI 组件。以下是一个 React 示例：

```tsx
// 从编辑器状态中获取变更
const storage = editor.extensionStorage.aichange
const changes = storage.getchanges()

// 在 UI 中渲染变更列表
return (
  <div>
    {changes.map((change) => (
      <div key={change.id}>
        <button onClick={() => editor.commands.acceptAiChange(change.id)}>接受</button>
        <button onClick={() => editor.commands.rejectAiChange(change.id)}>拒绝</button>
      </div>
    ))}
  </div>
)
```

## 隐藏和显示变更

在某些场景下，你可能希望继续跟踪变更，但在界面上暂时隐藏它们，例如当你在流式输出 AI 生成内容时。你可以使用 `setShowAiChanges` 命令以编程方式隐藏或显示变更。

```ts
// 隐藏变更
editor.commands.setShowAiChanges(false)

// 显示变更
editor.commands.setShowAiChanges(true)
```

这只会影响变更的视觉显示——跟踪机制仍在后台工作，所有变更仍可通过扩展存储方法访问。