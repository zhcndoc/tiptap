---
title: 内联编辑
meta:
  title: 内联编辑 | Tiptap Content AI
  description: 对文档进行简单的小范围编辑。选中内容后，根据您的指令让 AI 模型重新编写。
  category: Content AI
---

import { CodeDemo } from '@/components/CodeDemo'
import { Callout } from '@/components/ui/Callout'
import { Requirements, RequirementItem } from '@/components/Requirements'

<Requirements>
  <RequirementItem label="1. 获取访问权限">
      通过购买付费的 AI Toolkit 插件获得 AI Toolkit 扩展访问权限。<a href="https://tiptap.dev/contact-sales?form=ai-toolkit">联系我们的团队</a>。
  </RequirementItem>
  <RequirementItem label="2. 访问私有仓库">
    AI Toolkit 扩展发布在 Tiptap 的私有 npm 仓库中。请按照 [设置指南](/guides/pro-extensions) 验证登录 Tiptap 的私有 npm 仓库。
  </RequirementItem>
  <RequirementItem label="3. 安装扩展">
    使用 npm 或您偏好的包管理器从私有仓库安装扩展。
  </RequirementItem>
</Requirements>

对文档进行简单的小范围编辑。选中内容后，根据您的指令让 AI 模型重新编写。

<CodeDemo path="" isScrollable src="https://ai-toolkit-demos.vercel.app/inline-edits" />

查看 [GitHub 上的源码](https://github.com/ueberdosis/ai-toolkit-demos)。

## 技术栈

- [React](https://react.dev/) + [Next.js](https://nextjs.org/)
- [Vercel 的 AI SDK](https://ai-sdk.dev/) + [OpenAI](https://openai.com/) 模型
- Tiptap AI Toolkit

## 安装

创建一个 [Next.js](https://nextjs.org/) 项目：

```bash
npx create-next-app@latest inline-edits
```

安装核心的 Tiptap 包和用于 OpenAI 的 [Vercel AI SDK](https://ai-sdk.dev/)：

```bash
npm install @tiptap/react @tiptap/starter-kit ai @ai-sdk/react @ai-sdk/openai
```

安装 Tiptap AI Toolkit 及 Vercel AI SDK 的工具定义。

<Callout title="Pro 套餐" variant="hint">
  AI Toolkit 是一款专业版套餐。安装前请先按照 [私有仓库指南](/guides/pro-extensions) 设置对私有 NPM 仓库的访问权限。
</Callout>

```bash
npm install @tiptap-pro/ai-toolkit @tiptap-pro/ai-toolkit-ai-sdk
```

## API 接口

创建一个 API 接口 `/api/inline-edits`，使用 [Vercel AI SDK](https://ai-sdk.dev/) 调用 OpenAI 模型。该接口接收两个参数：

- `userRequest`（`string`）：用户对选区的编辑请求。例如：“给这段文本添加表情符号”
- `selection`（`string`）：当前选区的内容，HTML 格式

接口调用 AI 模型，要求它重新编写选区内容。

```ts
// app/api/inline-edits/route.ts
import { openai } from '@ai-sdk/openai'
import { streamText } from 'ai'

export async function POST(req: Request) {
  const { userRequest, selection } = await req.json()

  const result = streamText({
    model: openai('gpt-5-mini'),
    system: `你是一位擅长编辑富文本档案的写作专家。
用户选中了文档的一部分。你将收到选区当前的内容（HTML 格式）和用户的请求。请重写选区内容以满足用户请求。生成新的选区内容的 HTML 代码。如果用户的请求不明确或与编辑文档无关，请生成 HTML 代码，请用户澄清请求。你的回复仅包含 HTML 代码，不含其他文本或解释，不使用 Markdown，HTML 代码不应被反引号、Markdown 代码块或其他额外格式包裹。`,
    prompt: `用户请求：
"""
${userRequest}
"""
选区内容：
"""
${selection}
"""`,
  })

  // 直接返回文本流响应
  return result.toTextStreamResponse()
}
```

要访问 OpenAI API，请在 [OpenAI 控制台](https://platform.openai.com/account/api-keys) 创建 API 密钥，并作为 [环境变量](https://nextjs.org/docs/app/guides/environment-variables) 添加。Vercel AI SDK 会自动检测该环境变量。

```sh
# .env
OPENAI_API_KEY=your-api-key
```

## 客户端

创建一个客户端 React 组件，渲染 Tiptap 编辑器和一个按钮，点击按钮时调用 AI 模型为选中文本添加表情符号。

```tsx
// app/page.tsx
'use client'

import { EditorContent, useEditor, useEditorState } from '@tiptap/react'
import StarterKit from '@tiptap/starter-kit'
import { useState } from 'react'
import { AiToolkit, getAiToolkit } from '@tiptap-pro/ai-toolkit'

export default function Page() {
  const editor = useEditor({
    immediatelyRender: false,
    extensions: [StarterKit, AiToolkit],
    content: `<p>请选中一些文本，然后点击“添加表情符号”按钮，为选区添加表情。</p>`,
  })

  if (!editor) return null

  return (
    <>
      <EditorContent editor={editor} />
      <button>添加表情符号</button>
    </>
  )
}
```

接下来，创建一个 `editSelection` 函数，在点击按钮时调用 AI 模型。

在此函数中，通过 AI Toolkit 的 `getHtmlSelection` 方法获取当前选区内容的 HTML。然后调用 API 接口，传入用户请求和选区。接口返回的 HTML 流可以通过 AI Toolkit 的 `streamHtml` 方法插入编辑器。

```tsx
// 显示 AI 生成内容时的加载状态
const [isLoading, setIsLoading] = useState(false)

// 创建函数，以 AI 生成的内容编辑选区
const editSelection = async (userRequest: string) => {
  if (!editor) return

  const toolkit = getAiToolkit(editor)

  // 使用 AI Toolkit 获取选区 HTML
  const selection = toolkit.getHtmlSelection()

  setIsLoading(true)

  // 调用接口获取编辑后的 HTML 内容
  const response = await fetch('/api/inline-edits', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      userRequest,
      selection,
    }),
  })

  if (!response.ok) {
    throw new Error(`HTTP 错误！状态码: ${response.status}`)
  }

  // 响应为 HTML 内容流
  const readableStream = response.body
  if (!readableStream) {
    throw new Error('响应体为空')
  }

  // 使用 AI Toolkit 将 HTML 流插入选区
  await toolkit.streamHtml(readableStream, { position: 'selection' })
  setIsLoading(false)
}
```

最后，将 `editSelection` 函数添加至 React 组件，并在点击按钮时调用。

```tsx
// 点击按钮时调用 editSelection 函数
<button onClick={() => editSelection('给这段文本添加表情符号')}>添加表情符号</button>
```

完整的 React 组件如下：

```tsx
// app/page.tsx
'use client'

import { EditorContent, useEditor, useEditorState } from '@tiptap/react'
import StarterKit from '@tiptap/starter-kit'
import { useState } from 'react'
import { AiToolkit, getAiToolkit } from '@tiptap-pro/ai-toolkit'

export default function Page() {
  const editor = useEditor({
    immediatelyRender: false,
    extensions: [StarterKit, AiToolkit],
    content: `<p>请选中一些文本，然后点击“添加表情符号”按钮，为选区添加表情。</p>`,
  })

  // AI 内容生成时禁用按钮
  const [isLoading, setIsLoading] = useState(false)

  // 选区为空时禁用按钮
  const selectionIsEmpty = useEditorState({
    editor,
    selector: (snapshot) => snapshot.editor?.state.selection.empty ?? true,
  })

  if (!editor) return null

  const editSelection = async (userRequest: string) => {
    const toolkit = getAiToolkit(editor)

    // 获取 HTML 格式的选区内容
    const selection = toolkit.getHtmlSelection()

    setIsLoading(true)

    // 调用 API 获取编辑后的 HTML
    const response = await fetch('/api/inline-edits', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        userRequest,
        selection,
      }),
    })

    if (!response.ok) {
      throw new Error(`HTTP 错误！状态码: ${response.status}`)
    }

    const readableStream = response.body
    if (!readableStream) {
      throw new Error('响应体为空')
    }

    await toolkit.streamHtml(readableStream, { position: 'selection' })
    setIsLoading(false)
  }

  const disabled = selectionIsEmpty || isLoading

  return (
    <>
      <EditorContent editor={editor} />
      <button onClick={() => editSelection('给这段文本添加表情符号')} disabled={disabled}>
        {isLoading ? '加载中...' : '添加表情符号'}
      </button>
    </>
  )
}
```

## 最终效果

通过附加的 CSS 样式，效果是一个简洁且美观的文本编辑器，带有按钮可通过 AI 编辑选区内容：

<CodeDemo path="" isScrollable src="https://ai-toolkit-demos.vercel.app/inline-edits" />

查看 [GitHub 上的源码](https://github.com/ueberdosis/ai-toolkit-demos)。

## 后续步骤

- 查看 `streamHtml` 方法的 [API 参考](/content-ai/capabilities/ai-toolkit/primitives/edit-the-document#streamhtml)，了解如何在 AI 生成内容后显示预览界面。
- 通过向 AI 提供更多上下文（例如选区前后的内容）增强效果。可以使用 `getHtmlRange` 方法（[参见 API 参考](/content-ai/capabilities/ai-toolkit/primitives/read-the-document#gethtmlrange)）。
- 使用 [Selection 扩展](/editor/extensions/functionality/selection) 让选区在编辑器失焦时依然显示。
