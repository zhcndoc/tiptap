---
title: 集成自定义大语言模型（LLM）
meta:
  title: 自定义LLM | Tiptap 内容AI
  description: 通过生成式AI扩展实现自定义LLM，并在编辑器中覆盖解析器函数。请查阅文档了解更多信息！
  category: 内容AI
---

import { Callout } from '@/components/ui/Callout'

如果你想使用自己的后端来提供访问自定义LLM的能力，可以在扩展配置中覆盖以下定义的解析器函数。

请确保你返回的是正确类型的响应，并且正确处理错误。

<Callout title="温馨提示！" variant="hint">
  强烈建议你不要在前端直接调用OpenAI接口，这可能导致API令牌泄露！你应当通过后端代理来保护你的API令牌安全。
</Callout>

## 安装 AI 扩展

为了使用自定义解析器函数，你需要安装我们的 Tiptap AI 扩展。

<Callout title="专业版扩展" variant="warning">

    此扩展需要有效订阅且处于合适计划中，并且需要[访问我们的私有注册表](/guides/pro-extensions)，请先完成相关设置。

    **使用此扩展必须是企业客户。**

</Callout>

```bash
npm install @tiptap-pro/extension-ai@next
```

### 同时使用自定义LLM和Tiptap AI云服务

如果你想部分情况下依赖我们的云服务，请确保你[按照这里的说明完成团队设置](/content-ai/capabilities/generation/install#start-your-content-ai-app)。

## 解析器函数

你可以在扩展选项中定义自定义解析器函数。请注意，它们期望返回以下类型。

| 类型       | 方法名                 | 返回类型                                       |
| ---------- | ---------------------- | --------------------------------------------- |
| 文字补全   | `aiCompletionResolver` | `Promise<string \| null>`                      |
| 流式输出   | `aiStreamResolver`     | `Promise<ReadableStream<Uint8Array> \| null>` |
| 图片生成   | `aiImageResolver`      | `Promise<string \| null>`                      |

使用 `aiCompletionResolver` 以非流式方式向编辑器添加文本。

使用 `aiStreamResolver` 可将内容直接流入编辑器，从而实现编辑器的打字机效果。

确保流返回的是 HTML，以便 Tiptap 可以直接将内容渲染为富文本。这种方式免去了 Markdown 解析的需要，并保持前端轻量。

## 示例

### 在补全模式下覆盖特定命令解析

本示例中，当调用 `rephrase` 操作/命令时，我们希望调用自定义后端。
其他所有操作都应由 Tiptap 云的默认后端处理。

```js
// ...
import Ai from '@tiptap-pro/extension-ai'
// ...

Ai.configure({
  appId: 'APP_ID_HERE',
  token: 'TOKEN_HERE',
  // ...
  onError(error, context) {
    // 错误处理
  },
  // 定义补全解析器函数（注意：流式和图片解析器需分别定义！）
  aiCompletionResolver: async ({
    editor,
    action,
    text,
    textOptions,
    extensionOptions,
    defaultResolver,
  }) => {
    // 根据 action、text 等条件判断
    // 决定是否调用自定义接口
    if (action === 'rephrase') {
      const response = await fetch('https://dummyjson.com/quotes/random')
      const json = await response?.json()

      if (!response.ok) {
        throw new Error(`${response.status} ${json?.message}`)
      }

      return json?.quote
    }

    // 其他请求交由 Tiptap AI 服务处理
    return defaultResolver({
      editor,
      action,
      text,
      textOptions,
      extensionOptions,
      defaultResolver,
    })
  },
})
```

### 注册一个新的AI命令并调用自定义后端操作

本示例中，我们注册了一个新的编辑器命令 `aiCustomTextCommand`，使用 Tiptap 的 `runAiTextCommand` 函数让 Tiptap 处理其余操作，并添加自定义命令解析以调用自定义后端（补全模式）。

```js
// …
import { Ai, runAiTextCommand } from '@tiptap-pro/extension-ai'
// …

// 如果使用 TypeScript，请声明类型：
//
// declare module '@tiptap/core' {
//   interface Commands<ReturnType> {
//     ai: {
//       aiCustomTextCommand: () => ReturnType,
//     }
//   }
// }

const AiExtended = Ai.extend({
  addCommands() {
    return {
      ...this.parent?.(),

      aiCustomTextCommand:
        (options = {}) =>
        (props) => {
          // 你可以自行处理，例如获取选中文本并传入特定命令解析
          return runAiTextCommand(props, 'customCommand', options)
        },
    }
  },
})

// … 你需要在此处初始化你的 Tiptap 编辑器实例并注册扩展

const editor = new Editor{
  extensions: [
    /* … 添加其他扩展 */
    AiExtended.configure({
      /* … 添加配置（appId, token 等） */
      onError(error, context) {
        // 错误处理
      },
      aiCompletionResolver: async ({
        action,
        text,
        textOptions,
        extensionOptions,
        defaultResolver,
        editor,
      }) => {
        if (action === 'customCommand') {
          const response = await fetch('https://dummyjson.com/quotes/random')
          const json = await response?.json()

          if (!response.ok) {
            throw new Error(`${response.status} ${json?.message}`)
          }

          return json?.quote
        }

        return defaultResolver({
          editor,
          action,
          text,
          textOptions,
          extensionOptions,
          defaultResolver,
        })
      },
    }),
  ],
  content: '',
})

// … 使用此命令运行你的新指令：
// editor.chain().focus().aiCustomTextCommand().run()
```

### 在流式模式下使用自定义后端

本示例中，我们完全依赖自定义后端。

确保函数 `aiStreamResolver` 返回的是一个 `ReadableStream<Uint8Array>`。

另外请注意：如果你既想使用流式模式，又想使用传统的补全模式（非流式），你还需要定义一个 `aiCompletionResolver`！

```js
// ...
import Ai from '@tiptap-pro/extension-ai'
// ...

Ai.configure({
  appId: 'APP_ID_HERE',
  token: 'TOKEN_HERE',
  // ...
  onError(error, context) {
    // 错误处理
  },
  // 定义流式解析器函数
  aiStreamResolver: async ({ action, text, textOptions }) => {
    const fetchOptions = {
      method: 'POST',
      headers: {
        accept: 'application/json',
        'content-type': 'application/json',
      },
      body: JSON.stringify({
        ...textOptions,
        text,
      }),
    }

    const response = await fetch(`<YOUR_STREAMED_BACKEND_ENDPOINT>`, fetchOptions)
    const json = await response?.json()

    if (!response.ok) {
      throw new Error(`${json?.error} ${json?.message}`)
    }

    return response?.body
  },
})
```