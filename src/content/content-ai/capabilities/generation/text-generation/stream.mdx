---
title: 将内容流式传输到编辑器
meta:
  title: 流式内容 | Tiptap 内容 AI
  description: 用于将内容直接流式传输到编辑器内容的底层 API。更多信息请查看我们的文档。
  category: 内容 AI
---

import { Callout } from '@/components/ui/Callout'
import { Requirements, RequirementItem } from '@/components/Requirements'

<Requirements>
    <RequirementItem label="1. 激活试用或订阅">
        在您的[账户](https://cloud.tiptap.dev/v2/billing)中开始免费试用，或订阅一个[Tiptap 计划](https://cloud.tiptap.dev/v2/billing)。
    </RequirementItem>
    <RequirementItem label="2. 集成 AI 提供商">
        在您的[AI 设置](https://cloud.tiptap.dev/v2/cloud/ai)中配置 OpenAI，或查看[自定义 LLM 指南](/content-ai/capabilities/generation/custom-llms)。
    </RequirementItem>
    <RequirementItem label="3. 从私有仓库安装">
        若要安装前端扩展，请按照[设置指南](/guides/pro-extensions)认证登录 Tiptap 的私有 npm 仓库。
    </RequirementItem>
</Requirements>

`streamContent` 命令是一个将内容流式传输到编辑器的底层 API。它支持追加内容和替换指定范围的内容。当您需要将类似 LLM 模型响应的内容流式传输到编辑器时，此命令非常有用。

<Callout title="高级集成">
  该命令适用于需要从 URL 或响应体中流式传输内容到编辑器的高级集成场景。
</Callout>

### 参数

**range**：要插入内容的单个位置，或指定替换范围的对象，包含 `from` 和 `to` 属性。<br/>
**callback**：一个接收写入函数，将内容流式传输到编辑器的异步函数。

### `callback` 的参数

**getWritableStream**：返回一个可写流对象，可用于向编辑器写入数据片段。<br/>
**write**：接收一个对象，该对象包含以下属性的函数：

- `partial`：要插入到编辑器中的内容。
- `transform`：可选函数，接收以下属性的对象：
  - `buffer`：流的累积内容。
  - `partial`：当前的部分内容。
  - `editor`：编辑器实例。
  - `defaultTransform`：默认的转换函数，该函数接收累积内容并将其插入编辑器。
- `appendToChain`：可选函数，用于将命令添加到命令链中。

## 示例用法

### 使用 `write` API

此示例展示了 `streamContent` 命令的灵活性，通过从 URL 获取一个大数据流并将其逐块流式传输到编辑器。

```ts
editor.commands.streamContent({ from: 0, to: 10 }, async ({ write }) => {
  const response = await fetch('https://example.com/stream')
  const reader = response.body?.getReader()
  const decoder = new TextDecoder('utf-8')

  if (!reader) {
    throw new Error('无法从响应体获取读取器。')
  }

  while (true) {
    const { done, value } = await reader.read()
    if (done) break

    const chunk = decoder.decode(value, { stream: true })
    write({ partial: chunk })
  }
})
```

### 使用 `getWritableStream` API

该示例展示了使用 `WritableStream` 对象将内容流式传输到编辑器的另一种方式。

```ts
editor.commands.streamContent({ from: 0, to: 10 }, async ({ getWritableStream }) => {
  const response = await fetch('https://example.com/stream')
  // 这将直接将响应体内容管道到编辑器中
  await response.body?.pipeTo(getWritableStream())
})
```

### 使用内容转换

您也可以使用 `transform` 函数在将内容流式传输到编辑器之前对其进行修改。此示例演示了如何在流式传输前转换内容。

```ts
editor.commands.streamContent({ from: 0, to: 10 }, async ({ write }) => {
  const response = await fetch('https://example.com/stream')
  const reader = response.body?.getReader()
  const decoder = new TextDecoder('utf-8')

  if (!reader) {
    throw new Error('无法从响应体获取读取器。')
  }

  while (true) {
    const { done, value } = await reader.read()
    if (done) break

    const chunk = decoder.decode(value, { stream: true })

    write({
      partial: transformedChunk,
      transform: ({ buffer, partial, editor, defaultTransform }) => {
        // 这将使用默认转换函数将整个缓存内容转换为大写并插入编辑器
        return defaultTransform(buffer.toUpperCase())
      },
    })
  }
})
```

**用例示例:** 从 URL 解析 Markdown 内容并流式传输到编辑器。

```ts
import { marked } from 'marked'

editor.commands.streamContent({ from: 0, to: 10 }, async ({ write }) => {
  const response = await fetch('https://example.com/stream')
  const reader = response.body?.getReader()
  const decoder = new TextDecoder('utf-8')

  if (!reader) {
    throw new Error('无法从响应体获取读取器。')
  }

  while (true) {
    const { done, value } = await reader.read()
    if (done) break

    const chunk = decoder.decode(value, { stream: true })

    write({
      partial: chunk,
      transform: ({ buffer, partial, editor, defaultTransform }) => {
        // 这将解析 Markdown 内容为 HTML 字符串并插入到编辑器中
        return defaultTransform(marked.parse(buffer))
      },
    })
  }
})
```

### 使用 `appendToChain` 选项

`appendToChain` 函数允许您在命令链执行前向链中追加命令。此示例展示了如何在执行前追加命令。

```ts
import { selectionToInsertionEnd } from '@tiptap/core'

editor.commands.streamContent({ from: 0, to: 10 }, async ({ write }) => {
  write({
    partial: token,
    appendToChain: (chain) =>
      chain
        // 将选择移动到插入内容的末尾
        .command(({ tr }) => {
          selectionToInsertionEnd(tr, tr.steps.length - 1, -1)
          return true
        })
        // 滚动编辑器视图至插入内容末尾
        .scrollIntoView(),
  })
})
```

### 使用 `streamContent` 的 `respondInline` 选项

默认情况下，`respondInline` 为 `true`。当向编辑器插入块级内容时，有时您可能希望将其作为同级节点插入，而不是直接作为块插入。您可以使用 `respondInline` 选项将内容插入到与 `from` 位置相同的深度。

```ts
editor.commands.setContent('<p>123</p>')
editor.commands.streamContent(
  4,
  async ({ write }) => {
    await new Promise((resolve) => {
      setTimeout(() => resolve(), 10)
    })
    write({ partial: '<p>hello ' })
    await new Promise((resolve) => {
      setTimeout(() => resolve(), 10)
    })
    write({ partial: 'world</p><p>ok</p>' })
  },
  { respondInline: true },
)
// 输出: <p>123hello world</p><p>ok</p>
// 与 `respondInline` 为 `false` 时的 <p>123</p><p>hello work</p><p>ok</p> 不同
```

## 技术细节

以下是 `streamContent` 命令的完整 TypeScript 定义：

```ts
declare module '@tiptap/core' {
  interface Commands<ReturnType> {
    streamContent: {
      streamContent: (
        /**
         * 插入内容的位置。
         */
        position: number | Range,
        /**
         * 将内容写入编辑器的回调。
         */
        callback: (options: StreamContentAPI) => Promise<any>,
        /**
         * 传递给 `insertContentAt` 命令的选项。
         */
        options?: {
          parseOptions?: NonNullable<
            Parameters<RawCommands['insertContentAt']>['2']
          >['parseOptions']
          /**
           * 内容将插入到与 `from` 位置相同深度。
           * 实质上，这会将内容作为 `from` 位置节点的同级节点插入。
           * @default true
           */
          respondInline?: boolean
        },
      ) => ReturnType
    }
  }
}

type StreamContentAPI = {
  /**
   * 向编辑器写入内容的函数。
   */
  write: (ctx: {
    /**
     * 要插入的流的部分内容。
     */
    partial: string
    /**
     * 允许您在插入编辑器之前转换内容的函数。
     * 必须返回 Prosemirror 的 `Fragment` 或 `Node`。
     */
    transform?: (ctx: {
      /**
       * 流的累计内容。
       */
      buffer: string
      /**
       * 流的当前部分内容。
       */
      partial: string
      editor: Editor
      /**
       * 允许使用默认转换函数。
       */
      defaultTransform: (
        /**
         * 要作为 HTML 字符串插入的内容。
         * @default ctx.buffer
         */
        htmlString?: string,
      ) => Fragment
    }) => Fragment | Node | Node[]
    /**
     * 允许您在命令链执行前追加命令。
     */
    appendToChain?: (chain: ChainedCommands) => ChainedCommands
  }) => {
    /**
     * 正在写入的缓存。
     */
    buffer: string
    /**
     * 编辑器中插入内容的起始位置。
     */
    from: number
    /**
     * 编辑器中插入内容的结束位置。
     */
    to: number
  }
  /**
   * 一个可写流，用于向编辑器写入内容。
   * @example fetch('https://example.com/stream').then(response => response.body.pipeTo(ctx.getWritableStream()))
   */
  getWritableStream: () => WritableStream
}
```