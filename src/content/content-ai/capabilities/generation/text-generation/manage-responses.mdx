---
title: 存储和重新生成响应
meta:
  title: 管理响应 | Tiptap 内容 AI
  description: 使用内容 AI 存储保存、重新生成并插入 AI 响应到你的 Tiptap 编辑器。更多内容请查看我们的文档！
  category: 内容 AI
---

import { CodeDemo } from '@/components/CodeDemo'
import { Requirements, RequirementItem } from '@/components/Requirements'

<Requirements>
    <RequirementItem label="1. 启用试用或订阅">
        在你的账户中开始 [免费试用](https://cloud.tiptap.dev/v2/billing) 或订阅一个 [Tiptap 计划](https://cloud.tiptap.dev/v2/billing)。
    </RequirementItem>
    <RequirementItem label="2. 集成 AI 提供者">
        在你的 [AI 设置](https://cloud.tiptap.dev/v2/cloud/ai) 中配置 OpenAI，或查看 [自定义 LLM 指南](/content-ai/capabilities/generation/custom-llms)。
    </RequirementItem>
    <RequirementItem label="3. 从私有注册中心安装">
        要安装前端扩展，请根据 [设置指南](/guides/pro-extensions) 认证 Tiptap 的私有 npm 注册中心。
    </RequirementItem>
</Requirements>

AI 扩展会将当前状态存储在它的扩展存储中，位置为 `editor.storage.ai`。这个存储用于跟踪 AI 响应的当前状态，以及任何过往的响应。

<CodeDemo isPro path="/Extensions/AiStorage" />

| key           | type                                                                                    | definition                                                                                                                                                                                                                                                                                                   |
| ------------- | --------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| state         | `'loading' \| 'error' \| 'idle'`                                                       | 当 AI 正在生成响应时，状态设置为 `loading`。在响应生成后，状态设置为 `idle`。当发生错误时，状态设置为 `error`                                                                                                                       |
| response      | `string \| undefined`                                                                   | AI 生成的最新消息。当状态为 `idle` 时，如果这是一个字符串，它是之前生成的消息；如果为 `undefined`，则表示没有生成任何消息。当状态为 `loading` 时，这将是 AI 到目前为止生成的字符串（如果正在流式生成响应）。当状态为 `error` 时，这将是 `undefined` |
| error         | `Error \| undefined`                                                                    | 生成的错误，仅在错误状态时设置                                                                                                                                                                                                                                      |
| generatedWith | `{ action: TextAction; options: TextOptions; range: undefined \| Range; } \| undefined` | 描述最后一个生成的响应的选项；范围只有在插入内容到编辑器时才会设置                                                                                                                                                                                    |
| pastResponses | `string[]`                                                                              | 存储先前生成的响应（成功时），最新的在前。当响应被接受/拒绝时清除。                                                                                                                                                                                              |

你可以使用这个存储来读取当前 AI 响应的状态，如下所示：

```ts
const aiStorage = editor.storage.ai

if (aiStorage.response.state === 'error') {
  // 发生的错误
  aiStorage.response.error
}

if (aiStorage.response.state === 'loading') {
  // 当前正在处理的消息
  aiStorage.response.message
}

if (aiStorage.response.state === 'idle') {
  if (aiStorage.response.message) {
    // 成功的响应
    aiStorage.response.message
  } else {
    // 尚未请求响应
  }
}
```

## 使用 AI 存储

想要利用 Tiptap 内容 AI 生成结果，但又不希望结果在编辑器外部可用吗？你可以在任何 AI [TextOption](/content-ai/capabilities/generation/text-generation/built-in-commands#text-command-options) 上使用 `insert: false` ，这样它就会将结果存储到扩展中。

```ts
const chatMessage = '你好，你好吗？'

editor
  .chain()
  .aiTextPrompt({
    text: chatMessage,
    stream: true,
    insert: false,
    format: 'rich-text',
  })
  .run()
```

从那里，你可以使用 `aiAccept`、`aiReject` 和 `aiRegenerate` 命令。

### aiAccept

此命令在用户接受 AI 响应时执行，默认情况下它会将响应插入到编辑器中，并根据提供的选项改变行为。

| key      | type                                     | definition                                                                                                                                                                                                               |
| -------- | ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| insertAt | `number \| { from: number, to: number }` | 当为 `number` 时，接受响应并将其插入到编辑器的起始位置。当为 `{ from: number, to: number }` 时，接受响应并用 AI 响应替换从位置 `from` 到位置 `to` 的内容 |
| append   | `boolean`                                | 如果为 `true`，则不会替换当前选择，而是追加到当前选择后                                                                                                                                                        |

默认行为是在未提供选项的情况下，接受响应并将其插入到编辑器中，替换当前选择。

```ts
// 接受响应并将其插入到编辑器
editor.chain().aiAccept().run()

// 接受响应并将其插入到编辑器的起始位置
editor.chain().aiAccept({ insertAt: 0 }).run()

// 接受响应并将其插入到编辑器的末尾
editor.chain().aiAccept({ insertAt: editor.state.doc.content.size }).run()

// 接受响应并将其追加到当前选择
editor.chain().aiAccept({ append: true }).run()
```

### aiRegenerate

此命令在用户希望重试 AI 响应时执行，它将使用与之前 AI 文本操作相同的选项，并添加到 `editor.storage.ai.pastResponses` 数组中。

| key      | type                                     | definition                                                                                                                                                                                                                                                                                                                   |
| -------- | ---------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| insert   | `boolean`                                | 是否将重新生成的响应插入到编辑器中                                                                                                                                                                                                                                                                                   |
| insertAt | `number \| { from: number, to: number }` | 如果未指定，重新生成的响应将插入在之前响应的位置。当为 `number` 时，重新生成响应并将其插入到编辑器的开始。当为 `{ from: number, to: number }` 时，重新生成响应并用 AI 响应替换从位置 `from` 到位置 `to` 的内容                                                        |

默认行为是在未提供选项的情况下，重新生成响应并将其插入到编辑器中，替换当前选择。

```ts
// 重新生成响应并将其插入到编辑器
editor.chain().aiRegenerate().run()

// 重新生成响应并将其插入到编辑器的起始位置
editor.chain().aiRegenerate({ insertAt: 0 }).run()

// 重新生成响应并将其插入到编辑器的末尾
editor.chain().aiRegenerate({ insertAt: editor.state.doc.content.size }).run()

// 重新生成响应并将其追加到当前选择
editor.chain().aiRegenerate({ append: true }).run()
```

### aiReject

此命令在用户拒绝 AI 响应时执行，它将扩展的状态重置为初始闲置状态并清除所有 `editor.storage.ai.pastResponses`。

| key  | type               | definition                                                                                          |
| ---- | ------------------ | --------------------------------------------------------------------------------------------------- |
| type | 'reset' \| 'pause' | 是否将 AI 重置为闲置状态，或者只是暂停当前响应。默认值为 `'reset'` |

```ts
editor.chain().aiReject().run()

// 将不会清除 editor.storage.ai，这对于保持当前响应在编辑器存储中有用
editor.chain().aiReject({ type: 'pause' }).run()
```

## 高级示例

扩展存储的一个用例可能是渲染 AI 生成内容的预览。

为了在你的编辑器中渲染聊天的预览，我们可以使用你的编辑器的 schema 来生成将要生成的 HTML。使用这个 HTML 你可以在一个元素中显示内容的预览。

```tsx
// 将响应显示为 HTML
import { tryParseToTiptapHTML } from '@tiptap-pro/extension-ai'

// 尝试将当前消息解析为 HTML，如果无法解析则返回 null
tryToParseToHTML(editor.storage.ai.response.message, editor)

// 尝试将之前的响应解析为 HTML，如果无法解析则返回 null
tryToParseToHTML(editor.storage.ai.pastResponses[0], editor)

// 例如在 React 中
function PreviewComponent({ editor }) {
  const htmlResponse = tryToParseToHTML(editor.storage.ai.response.message, editor)
  /* 这是安全的，因为我们已经先用 prose-mirror 解析了内容 */
  return <div dangerouslySetInnerHTML={{ __html: htmlResponse }}></div>
}
```

请参见下面的演示，了解聊天预览是如何工作的一整套示例。

<CodeDemo isPro path="/Extensions/AiPrompt" />