---
title: React
meta:
  title: React | Tiptap 编辑器文档
  description: 学习如何将 Tiptap 编辑器与 React 应用集成，并开发自定义编辑器体验。
  category: 编辑器
---

import { CodeDemo } from '@/components/CodeDemo'
import { Callout } from '@/components/ui/Callout'

本指南描述了如何将 Tiptap 与您的 React 项目集成。我们使用 Vite，但其他设置的工作流程应该类似。

<CodeDemo path="/Examples/Default" />

## 创建一个 React 项目（可选）

以一个名为 `my-tiptap-project` 的新 React 项目开始。 [Vite](https://vitejs.dev/guide/) 将设置我们所需的一切。

```bash
# 使用 npm 创建项目
npm create vite@latest my-tiptap-project -- --template react-ts

# 或者，使用 pnpm 创建项目
pnpm create vite@latest my-tiptap-project --template react-ts

# 或者，使用 yarn 创建项目
yarn create vite my-tiptap-project --template react-ts

# 进入目录
cd my-tiptap-project
```

## 安装依赖

接下来，安装 `@tiptap/react` 包，`@tiptap/pm`（ProseMirror 库）和 `@tiptap/starter-kit`，它包括启动时常用的扩展。

- **@tiptap/react**：Tiptap 的 React 绑定，包括 Tiptap 的核心功能。
- **@tiptap/pm**：Tiptap 的 ProseMirror 依赖，是编辑器正常工作的必需库。
- **@tiptap/starter-kit**：一组常用扩展，提供段落、标题、加粗、斜体等基本功能。

```bash
npm install @tiptap/react @tiptap/pm @tiptap/starter-kit
```

如果您按照步骤 1 和 2 操作，现在可以通过 `npm run dev` 启动项目，并在浏览器中打开 [http://localhost:3000](http://localhost:3000)。

## 集成 Tiptap

Tiptap 提供了一个声明式的 `<Tiptap>` 组件，简化了编辑器的设置并为所有子组件提供上下文。这是将 Tiptap 与 React 集成的推荐方法。

### 使用 Tiptap 组件

创建一个名为 `Editor` 的新组件，并在 `src/Editor.tsx` 中添加以下代码：

```tsx
// src/Editor.tsx
import { Tiptap, useEditor } from '@tiptap/react'
import StarterKit from '@tiptap/starter-kit'

function Editor() {
  const editor = useEditor({
    extensions: [StarterKit],
    content: '<p>Hello World!</p>',
  })

  return (
    <Tiptap instance={editor}>
      <Tiptap.Loading>Loading editor...</Tiptap.Loading>
      <MenuBar />
      <Tiptap.Content />
      <Tiptap.BubbleMenu>
        <button>Bold</button>
        <button>Italic</button>
      </Tiptap.BubbleMenu>
      <Tiptap.FloatingMenu>
        <button>Add heading</button>
      </Tiptap.FloatingMenu>
    </Tiptap>
  )
}

export default Editor
```

`<Tiptap>` 组件提供多个子组件：

| 组件 | 描述 |
| --- | --- |
| `Tiptap.Content` | 渲染编辑器内容区域。替代 `<EditorContent editor={editor} />`。 |
| `Tiptap.Loading` | 仅在编辑器初始化时渲染其子内容。 |
| `Tiptap.BubbleMenu` | 文字选中时出现的上下文气泡菜单。 |
| `Tiptap.FloatingMenu` | 空白行时出现的上下文浮动菜单。 |

### 将其添加到您的应用中

用新的 `Editor` 组件替换 `src/App.tsx` 的内容：

```tsx
import Editor from './Editor'

function App() {
  return (
    <div className="card">
      <Editor />
    </div>
  )
}

export default App
```

## 在子组件中访问编辑器实例

`<Tiptap>` 组件提供上下文，允许任何子组件通过 `useTiptap` 钩子访问编辑器实例。

### 使用 useTiptap

`useTiptap` 钩子返回编辑器实例和一个 `isReady` 标志，用来指示编辑器是否完成初始化。

```tsx
import { useTiptap } from '@tiptap/react'

function MenuBar() {
  const { editor, isReady } = useTiptap()

  if (!isReady || !editor) {
    return null
  }

  return (
    <div className="menu-bar">
      <button
        onClick={() => editor.chain().focus().toggleBold().run()}
        className={editor.isActive('bold') ? 'is-active' : ''}
      >
        Bold
      </button>
      <button
        onClick={() => editor.chain().focus().toggleItalic().run()}
        className={editor.isActive('italic') ? 'is-active' : ''}
      >
        Italic
      </button>
    </div>
  )
}
```

然后将菜单栏包含进您的编辑器：

```tsx
<Tiptap instance={editor}>
  <MenuBar />
  <Tiptap.Content />
</Tiptap>
```

### 使用 useTiptapState 进行响应式状态管理

对于性能敏感的组件，可使用 `useTiptapState` 订阅编辑器状态的特定部分，避免无关状态变化导致组件重新渲染。

```tsx
import { useTiptap, useTiptapState } from '@tiptap/react'

function WordCount() {
  const { isReady } = useTiptap()

  const wordCount = useTiptapState((state) => {
    const text = state.editor.state.doc.textContent
    return text.split(/\s+/).filter(Boolean).length
  })

  if (!isReady) {
    return null
  }

  return <span>{wordCount} words</span>
}
```

选择器函数接收一个 `EditorStateSnapshot`，应只返回组件需要的数据。组件仅在选中值变化时重新渲染。

<Callout title="重要" variant="warning">
  只有在编辑器已准备好时使用 `useTiptapState`。在渲染使用此钩子的组件前，请检查 `useTiptap()` 的 `isReady`。
</Callout>

## 另一种方案：使用 EditorContent 手动设置

对于需要更控制力的场景，可以直接使用 `EditorContent`：

```tsx
import { useEditor, EditorContent } from '@tiptap/react'
import { FloatingMenu, BubbleMenu } from '@tiptap/react/menus'
import StarterKit from '@tiptap/starter-kit'

function Editor() {
  const editor = useEditor({
    extensions: [StarterKit], // 定义您的扩展数组
    content: '<p>Hello World!</p>', // 初始内容
  })

  return (
    <>
      <EditorContent editor={editor} />
      <FloatingMenu editor={editor}>这是浮动菜单</FloatingMenu>
      <BubbleMenu editor={editor}>这是气泡菜单</BubbleMenu>
    </>
  )
}

export default Editor
```

此方法要求手动为每个组件传入 `editor` 属性。大多数情况下推荐使用 `<Tiptap>` 组件，它减少了模板代码并自动提供上下文。

## 在子组件中消费编辑器上下文

`<Tiptap>` 组件自动提供了 `EditorContext`，因此您也可以在其内部使用 `useCurrentEditor` 钩子，以兼容部分现有代码。

```tsx
import { useCurrentEditor } from '@tiptap/react'

function EditorJSONPreview() {
  const { editor } = useCurrentEditor()

  if (!editor) {
    return null
  }

  return <pre>{JSON.stringify(editor.getJSON(), null, 2)}</pre>
}
```

**重要**：如果您使用 `useEditor` 钩子来设置您的编辑器，则此方法无效。

您现在应该在浏览器中看到一个非常基础的 Tiptap 示例。

### 添加开始或结束插槽

由于 EditorContent 组件是由 `EditorProvider` 组件渲染的，因此我们现在无法直接定义在编辑器内容之前或之后渲染的位置。为此，我们可以在 `EditorProvider` 组件上使用 `slotBefore` 和 `slotAfter` 属性。

```tsx
<EditorProvider
  extensions={extensions}
  content={content}
  slotBefore={<MyEditorToolbar />}
  slotAfter={<MyEditorFooter />}
/>
```

### 容器属性

`EditorProvider` 组件接受一个 `editorContainerProps` 属性来传递属性到编辑器提供器的容器元素。

```tsx
<EditorProvider
  extensions={extensions}
  content={content}
  editorContainerProps={{ className: 'editor-container' }}
/>
```

## 响应编辑器状态变化

要响应编辑器状态变化，您可以使用 `@tiptap/react` 提供的 `useEditorState` 钩子。该钩子可用于从编辑器状态中获取信息，而不会导致编辑器组件或其子组件重新渲染。

```tsx
import { useEditorState } from '@tiptap/react'

function MyEditorComponent({ editor }) {
  const editorState = useEditorState({
    editor,

    // selector 函数用于选择您想要响应的状态
    selector: ({ editor }) => {
      if (!editor) return null

      return {
        isEditable: editor.isEditable,
        isBold: editor.isActive('bold'),
        isItalic: editor.isActive('italic'),
      }
    },
  })

  return <div>Bold active: {editorState?.isBold ? 'Yes' : 'No'}</div>
}
```

<Callout title="提示" variant="hint">
  使用 `<Tiptap>` 组件时，优先使用 `useTiptapState`，它会自动使用上下文中的编辑器实例。
</Callout>

## 在 React 中使用 Tiptap 进行 SSR

Tiptap 可以与 React 应用中的服务端渲染（SSR）一起使用。然而，为确保编辑器仅在客户端初始化，您需要在创建编辑器实例时使用 `immediatelyRender` 选项，防止它在服务器端渲染。

以下是一个设置 React 组件中 Tiptap SSR 的示例：

```tsx
'use client'

import { Tiptap, useEditor } from '@tiptap/react'
import StarterKit from '@tiptap/starter-kit'

export function MyEditor() {
  const editor = useEditor({
    extensions: [StarterKit],
    content: '<p>Hello World!</p>',
    // 禁用即时渲染以避免 SSR 问题
    immediatelyRender: false,
  })

  if (!editor) {
    return null // 确保编辑器初始化前不渲染
  }

  return (
    <Tiptap instance={editor}>
      <Tiptap.Loading>
        <div className="skeleton">Loading editor...</div>
      </Tiptap.Loading>
      <Tiptap.Content />
    </Tiptap>
  )
}
```

`Tiptap.Loading` 组件在 SSR 中非常有用，它会在编辑器于客户端初始化前显示占位内容。

## 优化您的性能

我们建议您访问[React 性能指南](/guides/performance)，以高效集成 Tiptap 编辑器。这将帮助您避免应用规模扩大时可能出现的问题。

## API 参考

### Tiptap 组件

根提供者组件，通过 React 上下文使编辑器实例可用。

| 参数 | 类型 | 描述 |
| --- | --- | --- |
| `instance` | `Editor \| null` | 来自 `useEditor()` 的编辑器实例 |
| `children` | `ReactNode` | 子组件 |

### useTiptap 钩子

返回 Tiptap 的上下文值。

```tsx
const { editor, isReady } = useTiptap()
```

| 属性 | 类型 | 描述 |
| --- | --- | --- |
| `editor` | `Editor \| null` | 编辑器实例 |
| `isReady` | `boolean` | 编辑器是否完成初始化 |

### useTiptapState 钩子

使用选择器函数订阅编辑器状态的一部分。

```tsx
const value = useTiptapState(selector, equalityFn?)
```

| 参数 | 类型 | 描述 |
| --- | --- | --- |
| `selector` | `(state: EditorStateSnapshot) => T` | 状态选择函数 |
| `equalityFn` | `(a: T, b: T) => boolean` | 可选的比较函数，控制重新渲染 |

## 接下来

- [配置您的编辑器](/editor/getting-started/configure)
- [为您的编辑器添加样式](/editor/getting-started/style-editor)
- [了解更多 Tiptap 的概念](/editor/core-concepts/introduction)
- [了解如何持久化编辑器状态](/editor/core-concepts/persistence)
- [开始构建您自己的扩展](/editor/extensions/custom-extensions)